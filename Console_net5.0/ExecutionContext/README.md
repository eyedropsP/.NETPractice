# ExecutionContext
参考<br>
[ufcpp実行コンテキスト](https://ufcpp.wordpress.com/2014/02/21/%E5%AE%9F%E8%A1%8C%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88/)

実行コンテキスト

スレッドが持っている情報

意識することなくみんなが共有している情報

スレッドを越えて情報を共有することができる

Static, ThreadLocalなどでは対応できない要件に有効

.Netのスレッドには以下のような機能があり、これを実行コンテキストと呼ぶ
- 基本的にはスレッドをまたいで自動的に情報を伝搬させる
- 明示的に伝搬を抑止することもできる

実態はExecutionContextクラス<br>
このクラスの主だった機能はinternalになっているため、他のクラスを介して触れることになる

### (例)
- セキュリティコンテキスト
    - SecurityContextクラス(System.Security名前空間)
    - サンドボックス内で動いているか全信頼で動いているかといった情報や、Windows認証に関する情報を持っている
- 論理呼び出しコンテキスト
    - CallContextクラス(System.Runtime.Remoting.Messaging名前空間)
    - (実行コンテキスト内で)スレッドをまたいで任意の情報共有をするためのスロット(データ格納場所)
  
論理呼び出しとはTask.Runなどを介した呼び出し方も含めた呼び出し関係のこと

```c#
static void Main()
{
  Sub();  // 直接の呼び出し関係
  Task.Run(() => Sub());    // 論理的な呼び出し関係
  // Subを直接呼んでいるのはラムダ式
  // そのラムダ式は元をたどるとTaskSchedulerが呼んでる
  // 論理的にはMainからSubを呼んでいるようなもの
}
static void Sub(){}
```

文脈を持つのは最終手段であまり頼るべきではない<br>
書き換え可能なものは否応にして危ない